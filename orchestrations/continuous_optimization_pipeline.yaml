name: continuous_optimization_pipeline
type: orchestration
version: 1.0.0
description: 'Long-running optimization pipeline that continuously improves a target
  component

  over hours or days. Implements checkpoint/restore, multiple optimization strategies,

  and self-optimization of its own patterns. Designed for production optimization

  workloads that need to run unattended for extended periods.

  '
author: ksi_system
timestamp: 2025-01-18 10:00:00+00:00
variables:
  target_component: '{{target_component}}'
  optimization_hours: 24
  checkpoint_interval: 30
  evaluation_interval: 5
  strategy_switch_threshold: 0.85
  convergence_threshold: 0.95
agents:
  pipeline_coordinator:
    component: components/core/system_orchestrator
    vars:
      agent_id: pipeline_coordinator
    prompt: 'You coordinate a long-running continuous optimization pipeline.


      ## MANDATORY: Start with:

      {"event": "agent:status", "data": {"agent_id": "{{agent_id}}", "status": "pipeline_initialized",
      "target": "{{target_component}}", "runtime_hours": {{optimization_hours}}}}


      ## Pipeline Overview:

      - Target: {{target_component}}

      - Total runtime: {{optimization_hours}} hours

      - Checkpoint every: {{checkpoint_interval}} minutes

      - Evaluate every: {{evaluation_interval}} minutes


      ## Your responsibilities:

      1. Initialize pipeline state with checkpoint system

      2. Coordinate optimization cycles across strategies

      3. Monitor convergence and switch strategies when needed

      4. Handle checkpoints for resilience

      5. Self-optimize the pipeline patterns based on performance


      ## MANDATORY: Create pipeline state entity:

      {"event": "state:entity:create", "data": {"type": "pipeline_state", "id": "optimization_pipeline_{{target_component}}",
      "properties": {"target": "{{target_component}}", "start_time": "NOW", "phase":
      "initialization", "cycles_completed": 0, "best_score": 0.0, "current_strategy":
      "exploration"}}}


      ## Pipeline Phases:


      ### Phase 1: Exploration (0-25% of runtime)

      - Try diverse optimization strategies

      - Build initial performance baselines

      - Identify promising directions


      ### Phase 2: Exploitation (25-75% of runtime)

      - Focus on best-performing strategies

      - Refine and iterate on improvements

      - Track convergence metrics


      ### Phase 3: Crystallization (75-100% of runtime)

      - Lock in best improvements

      - Create final optimized version

      - Document optimization patterns


      ## Checkpoint Protocol:

      Every {{checkpoint_interval}} minutes:

      {"event": "orchestration:checkpoint", "data": {"orchestration_id": "{{_orchestration_id}}",
      "state": {...}}}


      ## Self-Optimization:

      Track which strategies work best and adjust the pipeline itself:

      {"event": "composition:track_decision", "data": {"pattern": "continuous_optimization_pipeline",
      "decision": "strategy_adjustment", "context": {...}, "confidence": 0.8}}

      '
  strategy_explorer:
    component: components/core/system_orchestrator
    vars:
      agent_id: strategy_explorer
    prompt: 'You explore different optimization strategies during the exploration
      phase.


      ## MANDATORY: Start with:

      {"event": "agent:status", "data": {"agent_id": "{{agent_id}}", "status": "explorer_initialized"}}


      ## Available Strategies:

      1. **Gradient-based**: Small incremental improvements

      2. **Evolutionary**: Population-based search with mutations

      3. **Bayesian**: Model-based optimization with uncertainty

      4. **Swarm**: Collaborative multi-agent optimization

      5. **Hybrid**: Combine multiple approaches


      ## For each exploration cycle:

      1. Select a strategy based on past performance

      2. Generate variations using that strategy

      3. Track results and update strategy scores


      ## MANDATORY: Track exploration progress:

      {"event": "state:entity:update", "data": {"id": "optimization_pipeline_{{target_component}}",
      "properties": {"exploration_progress": {"strategies_tested": [...], "best_strategy":
      "...", "scores": {...}}}}}

      '
  continuous_evaluator:
    component: components/core/system_orchestrator
    vars:
      agent_id: continuous_evaluator
    prompt: 'You continuously evaluate optimization candidates every {{evaluation_interval}}
      minutes.


      ## MANDATORY: Start with:

      {"event": "agent:status", "data": {"agent_id": "{{agent_id}}", "status": "evaluator_initialized"}}


      ## Evaluation Protocol:

      1. Request evaluation of current best candidate

      2. Compare against baseline and previous best

      3. Calculate improvement metrics

      4. Trigger strategy changes if needed


      ## Track evaluation metrics:

      {"event": "state:entity:create", "data": {"type": "evaluation_metrics", "id":
      "metrics_{{target_component}}", "properties": {"baseline_score": 0.0, "current_score":
      0.0, "improvement_rate": 0.0, "convergence_rate": 0.0}}}


      ## Convergence Detection:

      When improvement_rate < 0.01 for 3 consecutive evaluations:

      {"event": "orchestration:event", "data": {"type": "convergence_detected", "confidence":
      0.9}}

      '
  checkpoint_manager:
    component: components/core/base_agent
    vars:
      agent_id: checkpoint_manager
    prompt: 'You manage checkpoints for the optimization pipeline.


      ## MANDATORY: Start with:

      {"event": "agent:status", "data": {"agent_id": "{{agent_id}}", "status": "checkpoint_manager_ready"}}


      ## Checkpoint every {{checkpoint_interval}} minutes:

      1. Gather current pipeline state

      2. Save optimization history

      3. Store best candidates

      4. Enable resume from any point


      ## Checkpoint structure:

      {"event": "state:entity:create", "data": {"type": "pipeline_checkpoint", "id":
      "checkpoint_{{timestamp}}", "properties": {"pipeline_id": "optimization_pipeline_{{target_component}}",
      "timestamp": "...", "state": {...}, "best_candidates": [...], "metrics": {...}}}}

      '
  pattern_learner:
    component: components/core/system_orchestrator
    vars:
      agent_id: pattern_learner
    prompt: 'You learn patterns from the optimization process to improve future runs.


      ## MANDATORY: Start with:

      {"event": "agent:status", "data": {"agent_id": "{{agent_id}}", "status": "pattern_learner_initialized"}}


      ## Pattern Recognition:

      1. Which strategies work best for different component types?

      2. What convergence patterns indicate good progress?

      3. When should strategies be switched?

      4. How can the pipeline itself be optimized?


      ## Document patterns:

      {"event": "state:entity:create", "data": {"type": "optimization_patterns", "id":
      "patterns_{{target_component}}", "properties": {"effective_strategies": {...},
      "convergence_patterns": {...}, "pipeline_improvements": [...]}}}


      ## Self-optimization suggestions:

      {"event": "composition:track_decision", "data": {"pattern": "continuous_optimization_pipeline",
      "decision": "pipeline_improvement", "context": {"suggestion": "...", "expected_gain":
      "..."}, "confidence": 0.85}}

      '
routing:
- from: pipeline_coordinator
  to: strategy_explorer
  pattern: PHASE:exploration
- from: pipeline_coordinator
  to: continuous_evaluator
  pattern: EVALUATE:*
- from: pipeline_coordinator
  to: checkpoint_manager
  pattern: CHECKPOINT:*
- from: strategy_explorer
  to: pipeline_coordinator
  pattern: STRATEGY_RESULT:*
- from: continuous_evaluator
  to: pipeline_coordinator
  pattern: CONVERGENCE:*|STRATEGY_CHANGE:*
- from: '*'
  to: pattern_learner
  pattern: OPTIMIZATION:*|PATTERN:*
completion:
  conditions:
  - type: time_elapsed
    hours: '{{optimization_hours}}'
  - type: convergence_reached
    threshold: '{{convergence_threshold}}'
  - type: manual_termination
metadata:
  tags:
  - long-running
  - continuous-optimization
  - self-improving
  - checkpoint-enabled
  - production-ready
  capabilities_required:
  - orchestration:checkpoint
  - state:entity:create
  - state:entity:update
  - composition:track_decision
  estimated_runtime: '{{optimization_hours}} hours'
  resource_requirements:
  - persistent_state
  - checkpoint_storage
  - continuous_evaluation
