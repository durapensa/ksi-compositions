name: game_theory_orchestration_v2
type: orchestration
version: 2.0.0
description: |
  An executable game theory orchestration pattern with AI-interpretable DSL.
  Demonstrates strategic decision-making, Nash equilibrium seeking, and 
  cooperative dynamics through concrete agent implementations.
author: claude_orchestrator
extends: game_theory_orchestration

# Define concrete agents that implement the game theory DSL
agents:
  game_orchestrator:
    profile: "base/agent_core"
    vars:
      pattern_name: "game_theory_orchestration_v2"
      role: "game_theory_orchestrator"
      expertise: "strategic_coordination"
      prompt: |
        You are a game theory orchestrator implementing strategic multi-agent coordination with MANDATORY KSI event reporting.
        
        ## MANDATORY: Start EVERY orchestration with:
        ```json
        {"event": "agent:status", "data": {"agent_id": "{{agent_id}}", "status": "orchestrator_initialized", "expertise": "game_theory"}}
        ```
        
        Your agent_id is: {{agent_id}}
        
        Your responsibilities:
        1. Initialize game environment using variables: game_type={{game_type}}, num_players={{num_players}}, max_rounds={{max_rounds}}
        2. Spawn strategy agents based on game requirements  
        3. Coordinate game rounds and track progress toward equilibrium
        4. Calculate payoffs and identify Nash equilibria
        5. Emit MANDATORY KSI events to track decisions and crystallize patterns
        
        Game Types:
        - cooperative: Enable coalition formation, Shapley values, Pareto optimization
        - competitive: Focus on Nash equilibrium, minimax strategies
        - mixed: Adaptive weights between cooperation and competition
        
        ## MANDATORY Event Emission Pattern
        
        ### Initialization (MANDATORY)
        "Initializing game environment. {"event": "state:entity:create", "data": {"type": "game_environment", "id": "{{agent_id}}_game", "properties": {"game_type": "{{game_type}}", "num_players": {{num_players}}, "max_rounds": {{max_rounds}}}}}
        
        Creating game state tracker... {"event": "state:entity:create", "data": {"type": "game_state", "id": "{{agent_id}}_state", "properties": {"current_round": 0, "nash_distance": 1.0, "social_welfare": 0}}}"
        
        ### Agent Spawning (MANDATORY)  
        "Spawning strategy agents. {"event": "state:entity:update", "data": {"id": "{{agent_id}}_game", "properties": {"phase": "agent_spawning", "agents_created": 0}}}
        
        Creating rational maximizer... {"event": "agent:spawn", "data": {"profile": "base/agent_core", "agent_id": "rational_{{agent_id}}", "vars": {"role": "rational_maximizer", "strategy": "maximize_utility"}}}
        
        Creating adaptive learner... {"event": "agent:spawn", "data": {"profile": "base/agent_core", "agent_id": "adaptive_{{agent_id}}", "vars": {"role": "adaptive_learner", "strategy": "evolve_strategy"}}}"
        
        ### Game Rounds (MANDATORY)
        "Starting game round. {"event": "state:entity:update", "data": {"id": "{{agent_id}}_state", "properties": {"current_round": 1, "phase": "strategy_collection"}}}
        
        Requesting strategies from agents... {"event": "message:send", "data": {"from": "{{agent_id}}", "to": "all_players", "content": "Submit your strategy for round 1"}}
        
        Calculating payoffs... {"event": "state:entity:update", "data": {"id": "{{agent_id}}_state", "properties": {"payoffs_calculated": true, "nash_distance": 0.3}}}
        
        Analyzing equilibrium convergence... {"event": "state:entity:update", "data": {"id": "{{agent_id}}_state", "properties": {"equilibrium_analysis": "converging", "convergence_rate": 0.7}}}"
        
        ### Completion (MANDATORY)
        "Game theory analysis complete. {"event": "agent:status", "data": {"agent_id": "{{agent_id}}", "status": "analysis_complete", "equilibrium_found": true, "social_welfare": 87.5}}
        
        Requesting orchestration termination... {"event": "orchestration:request_termination", "data": {"agent_id": "{{agent_id}}", "reason": "Game theory orchestration completed successfully"}}"
        
        Use the DSL strategy from orchestration_logic as your guide.
        IMPORTANT: Use your actual agent_id ({{agent_id}}) in all event data fields.

metadata:
  tags:
    - game-theory
    - strategic
    - executable
    - nash-equilibrium
    - ai-orchestrated
  capabilities_required:
    - agent:spawn
    - orchestration:aggregate
    - composition:track_decision
    - event:emit
  use_cases:
    - Multi-agent strategy optimization
    - Game theory experiments
    - Nash equilibrium discovery
    - Cooperative dynamics study

# Game theory-inspired natural language DSL (for orchestrator guidance)
orchestration_logic:
  description: |
    Natural language strategy for the orchestrator to follow.
    This DSL guides the concrete implementation.
  
  strategy: |
    INITIALIZE game_environment:
      CREATE payoff_matrix FOR {{game_type}}
      SPAWN {{num_players}} strategy_agents WITH diverse_profiles:
        - rational_maximizer: maximize expected utility
        - tit_for_tat: mirror opponent's last move
        - adaptive_learner: evolve strategy based on outcomes
        - random_explorer: explore strategy space
      
      EMIT "game:initialized" WITH {
        game_type, num_players, payoff_structure
      }
    
    EXECUTE game_rounds:
      FOR round IN 1..{{max_rounds}}:
        BROADCAST "game:round_start" TO all_agents
        
        COLLECT agent_strategies WITH timeout:
          EMIT "game:request_strategy" TO each_agent
          WAIT for responses OR timeout
        
        CALCULATE round_payoffs BASED_ON strategies
        UPDATE agent_scores AND reputation
        
        ANALYZE equilibrium_convergence:
          distance_to_nash = calculate_equilibrium_distance()
          IF distance_to_nash < threshold:
            EMIT "game:equilibrium_found" WITH details
        
        EMIT "composition:track_decision" WITH {
          round, strategies, payoffs, convergence_metrics
        }
        
        IF converged OR round == max_rounds:
          BREAK
    
    SYNTHESIZE results:
      IDENTIFY dominant_strategies
      CALCULATE social_welfare
      ASSESS equilibrium_properties
      
      IF novel_insights_discovered:
        EMIT "composition:fork" WITH improvements
    
    COMPLETE orchestration:
      EMIT "orchestration:request_termination" WITH {
        agent_id: "{{agent_id}}",
        reason: "Game theory orchestration completed successfully"
      }

# Routing rules for game flow - Updated to use legitimate KSI events
routing_rules:
  # Strategy coordination through message system
  - event: "message:send"
    condition: "content.includes('strategy')"
    to:
      agent_id: "{{target_agent}}"
    forward: true
  
  # Game state broadcasts to all strategy agents
  - event: "state:entity:update"
    condition: "type == 'game_state'"
    to:
      pattern: "strategy_*_{{agent_id}}"
    broadcast: true
  
  # Strategy responses back to orchestrator
  - event: "agent:status"
    condition: "status.includes('strategy')"
    to:
      agent_id: "game_orchestrator"
    forward: true

# Event transformers - Updated to use legitimate KSI events
transformers:
  # Transform state updates into agent spawning for strategy agents
  - source: "state:entity:update"
    target: "agent:spawn_from_component"
    condition: "type == 'game_environment' AND phase == 'agent_spawning'"
    mapping:
      component: "base/agent_core"
      agent_id: "strategy_{{index}}_{{agent_id}}"
      variables:
        role: "strategy_agent"
        strategy_type: "{{strategy_types[index]}}"
        game_context: "{{game_type}}"
  
  # Async equilibrium analysis using completion service
  - source: "state:entity:update"
    target: "completion:async"
    condition: "id.endsWith('_state') AND properties.equilibrium_analysis"
    async: true
    mapping:
      prompt: |
        Analyze game state for Nash equilibrium:
        Current Strategies: {{current_strategies}}
        Payoff History: {{payoff_history}}
        Game Type: {{game_type}}
        
        Calculate:
        1. Distance to Nash equilibrium
        2. Social welfare metrics
        3. Strategy stability analysis
        4. Convergence predictions
        
        Return analysis with confidence scores.
      model: "claude-cli/sonnet"
      agent_id: "{{agent_id}}"
      request_id: "equilibrium_{{timestamp}}"
    response_route:
      from: "completion:result"
      to: "state:entity:update"
      mapping:
        id: "{{agent_id}}_equilibrium_analysis"
        properties: "{{analysis_results}}"
  
  # Strategy aggregation through orchestration patterns
  - source: "message:send"
    target: "orchestration:aggregate"
    condition: "content.includes('strategy')"
    mapping:
      responses: "{{collected_strategies}}"
      method: "consensus"
      options:
        aggregation_function: "game_theoretic_consensus"
        consider_payoffs: true
        weight_by_reputation: true
        timeout_seconds: 30

# Performance metrics
performance:
  runs: 0
  metrics:
    avg_rounds_to_equilibrium: null
    equilibrium_efficiency: null
    cooperation_emergence_rate: null

# Variables with defaults
variables:
  game_type: "mixed"
  num_players: 4
  max_rounds: 100
  convergence_threshold: 0.05
  strategy_diversity: 0.3