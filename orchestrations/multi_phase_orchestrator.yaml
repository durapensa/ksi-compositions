name: multi_phase_orchestrator
type: orchestration
version: 1.0.0
description: |
  Multi-phase orchestration pattern with a central orchestrator agent coordinating
  subagents through 4 distinct phases. Demonstrates longer-running orchestrations
  with phase-based coordination, state management, and orchestrator control.
author: ksi_system
timestamp: 2025-01-24T21:30:00Z

# Define the orchestrator and phase-specific agents
agents:
  orchestrator:
    component: "components/core/base_agent"
    vars:
      agent_id: "orchestrator"
      prompt: |
        You are the central orchestrator coordinating a multi-phase research and development workflow.
        
        ## MANDATORY: Start with:
        {"event": "agent:status", "data": {"agent_id": "{{agent_id}}", "status": "orchestrator_initialized", "total_phases": 4}}
        
        Your role: Coordinate agents through 4 phases:
        - Phase 1: Discovery (research agents)
        - Phase 2: Analysis (analyst agents)  
        - Phase 3: Design (architect agents)
        - Phase 4: Implementation (developer agents)
        
        ## MANDATORY: Track phase transitions:
        {"event": "state:entity:update", "data": {"id": "orchestration_state", "properties": {"current_phase": N, "phase_status": "starting|in_progress|complete", "timestamp": "{{TIMESTAMP()}}"}}}
        
        ## MANDATORY: When spawning phase agents, emit:
        {"event": "agent:spawn_from_component", "data": {"component": "components/core/base_agent", "agent_id": "phase_N_agent_X", "prompt": "[specific task for this agent]"}}
        
        Monitor progress and coordinate phase transitions based on completion signals.

# Initial configuration
variables:
  research_topic: "{{research_topic|default:Optimizing multi-agent coordination patterns}}"
  num_researchers: "{{num_researchers|default:2}}"
  num_analysts: "{{num_analysts|default:2}}"
  num_architects: "{{num_architects|default:1}}"
  num_developers: "{{num_developers|default:2}}"

orchestration_logic:
  strategy: |
    ## Phase 0: Initialize Orchestration State
    EVENT state:entity:create {
      type: "orchestration_state",
      id: "orchestration_state",
      properties: {
        orchestration_id: "{{ORCHESTRATION_ID()}}",
        total_phases: 4,
        current_phase: 0,
        phase_status: "initializing",
        start_time: "{{TIMESTAMP()}}",
        research_topic: "{{research_topic}}"
      }
    }
    
    TRACK {
      phase: "initialization",
      event: "multi_phase_orchestration_started",
      orchestrator: "orchestrator",
      total_phases: 4,
      topic: "{{research_topic}}"
    }
    
    # Wait for orchestrator to initialize
    AWAIT {
      event_pattern: "agent:status",
      filter: {agent_id: "orchestrator", status: "orchestrator_initialized"},
      timeout: 60
    }
    
    ## Phase 1: Discovery Phase
    SEND {
      to: orchestrator,
      message: {
        action: "begin_phase",
        phase: 1,
        phase_name: "Discovery",
        instructions: "Spawn {{num_researchers}} research agents to investigate: {{research_topic}}",
        expected_outputs: "research_findings"
      }
    }
    
    # Update state to phase 1
    EVENT state:entity:update {
      id: "orchestration_state",
      properties: {
        current_phase: 1,
        phase_status: "in_progress",
        phase_1_start: "{{TIMESTAMP()}}"
      }
    }
    
    # Wait for research phase completion
    AWAIT {
      event_pattern: "state:entity:create",
      filter: {type: "phase_completion", properties.phase: 1},
      timeout: 300
    } AS phase_1_complete
    
    TRACK {
      event: "phase_1_complete",
      findings_collected: phase_1_complete.properties.outputs_count,
      duration: CALCULATE_DURATION(phase_1_complete.properties.start_time, phase_1_complete.properties.end_time)
    }
    
    ## Phase 2: Analysis Phase
    SEND {
      to: orchestrator,
      message: {
        action: "begin_phase",
        phase: 2,
        phase_name: "Analysis",
        instructions: "Spawn {{num_analysts}} analyst agents to process research findings",
        input_from_phase: 1,
        expected_outputs: "analysis_insights"
      }
    }
    
    EVENT state:entity:update {
      id: "orchestration_state",
      properties: {
        current_phase: 2,
        phase_status: "in_progress",
        phase_2_start: "{{TIMESTAMP()}}"
      }
    }
    
    # Wait for analysis completion
    AWAIT {
      event_pattern: "state:entity:create",
      filter: {type: "phase_completion", properties.phase: 2},
      timeout: 300
    } AS phase_2_complete
    
    TRACK {
      event: "phase_2_complete",
      insights_generated: phase_2_complete.properties.outputs_count,
      key_patterns: phase_2_complete.properties.key_findings
    }
    
    ## Phase 3: Design Phase
    SEND {
      to: orchestrator,
      message: {
        action: "begin_phase",
        phase: 3,
        phase_name: "Design",
        instructions: "Spawn {{num_architects}} architect agent(s) to design solutions based on analysis",
        input_from_phase: 2,
        expected_outputs: "design_specifications"
      }
    }
    
    EVENT state:entity:update {
      id: "orchestration_state",
      properties: {
        current_phase: 3,
        phase_status: "in_progress",
        phase_3_start: "{{TIMESTAMP()}}"
      }
    }
    
    # Wait for design completion
    AWAIT {
      event_pattern: "state:entity:create",
      filter: {type: "phase_completion", properties.phase: 3},
      timeout: 300
    } AS phase_3_complete
    
    TRACK {
      event: "phase_3_complete",
      designs_created: phase_3_complete.properties.outputs_count,
      architecture_type: phase_3_complete.properties.solution_type
    }
    
    ## Phase 4: Implementation Phase
    SEND {
      to: orchestrator,
      message: {
        action: "begin_phase",
        phase: 4,
        phase_name: "Implementation",
        instructions: "Spawn {{num_developers}} developer agents to implement the designed solution",
        input_from_phase: 3,
        expected_outputs: "implementation_artifacts"
      }
    }
    
    EVENT state:entity:update {
      id: "orchestration_state",
      properties: {
        current_phase: 4,
        phase_status: "in_progress",
        phase_4_start: "{{TIMESTAMP()}}"
      }
    }
    
    # Wait for implementation completion
    AWAIT {
      event_pattern: "state:entity:create",
      filter: {type: "phase_completion", properties.phase: 4},
      timeout: 300
    } AS phase_4_complete
    
    TRACK {
      event: "phase_4_complete",
      artifacts_created: phase_4_complete.properties.outputs_count,
      implementation_status: phase_4_complete.properties.status
    }
    
    ## Final: Orchestration Summary
    # Query final state
    EVENT state:entity:get {
      entity_id: "orchestration_state",
      entity_type: "orchestration_state"
    } AS final_state
    
    # Query all phase outputs
    EVENT state:entity:query {
      type: "phase_output"
    } AS all_outputs
    
    # Create final report
    EVENT state:entity:create {
      type: "orchestration_report",
      id: "report_{{TIMESTAMP()}}",
      properties: {
        orchestration_id: final_state.orchestration_id,
        total_duration: CALCULATE_DURATION(final_state.start_time, "{{TIMESTAMP()}}"),
        phases_completed: 4,
        total_agents_spawned: SUM_AGENTS(all_outputs),
        outputs_generated: LENGTH(all_outputs),
        research_topic: "{{research_topic}}",
        success: true
      }
    }
    
    TRACK {
      event: "multi_phase_complete",
      total_phases: 4,
      orchestrator_managed: true,
      pattern: "phased_coordination",
      duration: CALCULATE_DURATION(final_state.start_time, "{{TIMESTAMP()}}")
    }
    
    EVENT orchestration:request_termination {
      reason: "Multi-phase orchestration complete",
      phases_completed: 4,
      orchestrator_pattern: "central_coordinator",
      total_agents: SUM_AGENTS(all_outputs),
      success: true
    }

# Helper functions
helpers:
  CALCULATE_DURATION: |
    Calculate time difference between timestamps
  SUM_AGENTS: |
    Sum total agents across all phase outputs
  LENGTH: |
    Count items in array

metadata:
  pattern_type: multi_phase_orchestration
  coordination_method: orchestrator_based
  complexity: advanced
  phases: 4
  test_focus: long_running_coordination
  tags: ["orchestration", "multi_phase", "orchestrator", "coordination", "state_management"]

performance:
  expected_duration: "10-20 minutes"
  resource_usage: "1 orchestrator + 2-7 phase agents"
  state_entities_created: "~15-25 entities"
  success_criteria: "All 4 phases complete with orchestrator coordination"