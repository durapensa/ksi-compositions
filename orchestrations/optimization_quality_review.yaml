name: optimization_quality_review
type: orchestration
version: 1.0.0
description: 'Orchestration for reviewing optimized components and committing high-quality
  ones to git.

  Uses LLM-as-Judge supervisor to evaluate improvements and execute git operations.

  '
author: ksi_system
timestamp: 2025-07-23 19:00:00+00:00
variables:
  optimized_components: '{{optimized_components}}'
  optimization_id: '{{optimization_id|default:''manual_review''}}'
  auto_commit: '{{auto_commit|default:false}}'
agents:
  supervisor:
    component: components/agents/optimization_quality_supervisor
    vars:
      agent_id: quality_supervisor
      review_mode: comprehensive
  git_assistant:
    component: components/core/base_agent
    vars:
      agent_id: git_assistant
    prompt: 'You assist with git operations for approved components.


      ## MANDATORY: Start with:

      {"event": "agent:status", "data": {"agent_id": "{{agent_id}}", "status": "git_assistant_ready"}}


      When instructed to commit components:

      1. Stage the specified files

      2. Create descriptive commit messages

      3. Execute git operations

      4. Report results

      '
orchestration_logic:
  strategy: "## Phase 1: Initialize Review\nSTATE review_results = []\nSTATE approved_components\
    \ = []\nSTATE components_to_review = {{optimized_components}}\n\nTRACK {\n  event:\
    \ \"quality_review_started\",\n  optimization_id: \"{{optimization_id}}\",\n \
    \ component_count: LENGTH(components_to_review)\n}\n\n## Phase 2: Systematic Evaluation\n\
    FOREACH component_path IN components_to_review:\n  # Load optimized component\n\
    \  EVENT composition:get_component {\n    name: component_path\n  } AS optimized\n\
    \  \n  # Try to load original (may not exist if new)\n  STATE original_path =\
    \ REPLACE(component_path, \"_optimized\", \"\")\n  TRY:\n    EVENT composition:get_component\
    \ {\n      name: original_path\n    } AS original\n  CATCH:\n    STATE original\
    \ = null\n  \n  # Send to supervisor for evaluation\n  SEND {\n    to: supervisor,\n\
    \    message: {\n      action: \"evaluate_optimization\",\n      component_path:\
    \ component_path,\n      optimized_content: optimized.content,\n      original_content:\
    \ original ? original.content : null,\n      optimization_id: \"{{optimization_id}}\"\
    ,\n      metadata: optimized.frontmatter\n    }\n  }\n  \n  AWAIT {\n    from:\
    \ supervisor,\n    timeout: 120\n  } AS evaluation\n  \n  # Store evaluation result\n\
    \  STATE review_results = APPEND(review_results, {\n    component: component_path,\n\
    \    score: evaluation.score,\n    improvements: evaluation.improvements,\n  \
    \  recommendation: evaluation.recommendation,\n    details: evaluation.details\n\
    \  })\n  \n  # Track approved components\n  IF evaluation.recommendation == \"\
    commit\":\n    STATE approved_components = APPEND(approved_components, {\n   \
    \   path: component_path,\n      commit_message: evaluation.commit_message,\n\
    \      score: evaluation.score\n    })\n  \n  TRACK {\n    event: \"component_evaluated\"\
    ,\n    component: component_path,\n    score: evaluation.score,\n    recommendation:\
    \ evaluation.recommendation\n  }\n\n## Phase 3: Quality Report\nSTATE total_reviewed\
    \ = LENGTH(review_results)\nSTATE total_approved = LENGTH(approved_components)\n\
    STATE approval_rate = total_approved / total_reviewed\nSTATE average_score = AVERAGE(MAP(review_results,\
    \ \"score\"))\n\nEVENT state:entity:create {\n  type: \"optimization_review_report\"\
    ,\n  id: \"review_{{optimization_id}}\",\n  properties: {\n    optimization_id:\
    \ \"{{optimization_id}}\",\n    timestamp: NOW(),\n    total_reviewed: total_reviewed,\n\
    \    total_approved: total_approved,\n    approval_rate: approval_rate,\n    average_score:\
    \ average_score,\n    results: review_results,\n    approved_components: approved_components\n\
    \  }\n}\n\nTRACK {\n  event: \"review_summary\",\n  total_reviewed: total_reviewed,\n\
    \  total_approved: total_approved,\n  average_score: average_score,\n  top_improvements:\
    \ MOST_COMMON(FLATTEN(MAP(review_results, \"improvements\")), 3)\n}\n\n## Phase\
    \ 4: Git Operations (if enabled)\nIF {{auto_commit}} AND LENGTH(approved_components)\
    \ > 0:\n  SEND {\n    to: git_assistant,\n    message: {\n      action: \"commit_components\"\
    ,\n      components: approved_components,\n      batch_message: \"feat: Optimize\
    \ {{total_approved}} components via {{optimization_id}}\",\n      push_to_remote:\
    \ true\n    }\n  }\n  \n  AWAIT {\n    from: git_assistant,\n    timeout: 180\n\
    \  } AS git_result\n  \n  TRACK {\n    event: \"git_operations_complete\",\n \
    \   committed: git_result.success,\n    commit_sha: git_result.commit_sha,\n \
    \   components_committed: LENGTH(approved_components)\n  }\n\n## Phase 5: Recommendations\n\
    STATE recommendations = {\n  high_performers: FILTER(review_results, score >=\
    \ 9.0),\n  needs_iteration: FILTER(review_results, score >= 6.0 AND score < 8.0),\n\
    \  rejected: FILTER(review_results, score < 6.0)\n}\n\nIF LENGTH(recommendations.needs_iteration)\
    \ > 0:\n  TRACK {\n    event: \"iteration_recommended\",\n    components: MAP(recommendations.needs_iteration,\
    \ \"component\"),\n    suggestion: \"Run targeted optimization on these components\
    \ with specific objectives\"\n  }\n\nEVENT orchestration:request_termination {\n\
    \  reason: \"Quality review complete\",\n  approved: total_approved,\n  average_quality:\
    \ average_score,\n  committed: {{auto_commit}} ? LENGTH(approved_components) :\
    \ 0\n}\n"
helpers:
  AVERAGE: Calculate average of numeric array
  MOST_COMMON: Find N most common elements in array
  FLATTEN: Flatten nested arrays
metadata:
  pattern_type: quality_review
  evaluation_method: llm_as_judge
  git_integration: true
  tags:
  - optimization
  - quality
  - review
  - git
performance:
  expected_duration: 2-5 minutes per component
  resource_usage: 2 agents (supervisor + git assistant)
