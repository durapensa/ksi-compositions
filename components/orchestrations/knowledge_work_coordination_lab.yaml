name: knowledge_work_coordination_lab
component_type: orchestration
version: 1.0.0
description: 'A laboratory for testing different agent coordination mechanisms in
  knowledge work.

  Experiments with direct messaging (completion:async), state-based coordination,

  message bus patterns, and hybrid approaches. Discovers optimal communication

  strategies for different types of collaborative knowledge tasks.

  '
author: ksi_system
timestamp: 2025-07-23 20:30:00+00:00
variables:
  research_topic: '{{research_topic|default:''Future of human-AI collaboration''}}'
  coordination_methods: '{{coordination_methods|default:[''direct'', ''state'', ''hybrid'']}}'
  team_size: '{{team_size|default:3}}'
  experiment_duration: '{{experiment_duration|default:30}}'
agents:
  coordination_researcher:
    component: components/core/system_orchestrator
    expanded_capabilities:
    - orchestration
    vars:
      agent_id: coordination_researcher
    prompt: 'You research and implement different coordination mechanisms for knowledge
      work teams.


      ## MANDATORY: Start with:

      {"event": "agent:status", "data": {"agent_id": "{{agent_id}}", "status": "coordination_lab_initialized"}}


      ## Coordination Methods to Test:


      ### 1. Direct Messaging (completion:async)

      Agents communicate by sending prompts directly to each other:

      {"event": "completion:async", "data": {"agent_id": "target_agent", "prompt":
      "Based on my findings...", "event_notification": {"event": "message:received",
      "data": {...}}}}


      ### 2. State-Based Coordination

      Agents share information through state entities:

      {"event": "state:entity:create", "data": {"type": "research_findings", "id":
      "findings_123", "properties": {"content": "...", "author": "agent_id"}}}


      ### 3. Message Bus Pattern

      Agents publish/subscribe to topics:

      {"event": "message:publish", "data": {"topic": "research/insights", "content":
      "...", "sender": "agent_id"}}


      ### 4. Hybrid Approach

      Combine methods based on message type:

      - Urgent: Direct messaging

      - Data: State entities

      - Broadcasts: Message bus


      ## MANDATORY: Create experiment state:

      {"event": "state:entity:create", "data": {"type": "coordination_experiment",
      "id": "coord_lab_{{research_topic|slugify}}", "properties": {"methods_tested":
      [], "results": {}, "optimal_patterns": []}}}

      '
  knowledge_worker_template:
    component: components/personas/researchers/data_researcher
    vars:
      agent_id: knowledge_worker_{{index}}
      coordination_style: '{{coordination_style}}'
      prompt_extension: "\n## Your Coordination Style: {{coordination_style}}\n\n\
        {{#if (eq coordination_style \"direct\")}}\n### Direct Messaging Protocol\n\
        When you discover something important:\n{\"event\": \"completion:async\",\
        \ \"data\": {\"agent_id\": \"{{teammate_id}}\", \"prompt\": \"I discovered\
        \ that...\", \"event_notification\": {\"event\": \"insight:shared\", \"data\"\
        : {\"from\": \"{{agent_id}}\", \"insight\": \"...\"}}}}\n\nWhen you need input:\n\
        {\"event\": \"completion:async\", \"data\": {\"agent_id\": \"{{teammate_id}}\"\
        , \"prompt\": \"Can you analyze...\", \"context\": {\"request_type\": \"analysis\"\
        , \"priority\": \"high\"}}}\n{{/if}}\n\n{{#if (eq coordination_style \"state\"\
        )}}\n### State-Based Coordination Protocol\nShare findings via state:\n{\"\
        event\": \"state:entity:create\", \"data\": {\"type\": \"research_artifact\"\
        , \"id\": \"artifact_{{timestamp}}\", \"properties\": {\"content\": \"...\"\
        , \"author\": \"{{agent_id}}\", \"tags\": [\"insight\", \"data\"]}}}\n\nCheck\
        \ teammates' findings:\n{\"event\": \"state:entity:query\", \"data\": {\"\
        type\": \"research_artifact\", \"filter\": {\"author\": {\"$ne\": \"{{agent_id}}\"\
        }}}}\n{{/if}}\n\n{{#if (eq coordination_style \"hybrid\")}}\n### Hybrid Coordination\
        \ Protocol\n- **Urgent/Questions**: Use direct messaging\n- **Data/Findings**:\
        \ Store in state entities\n- **Announcements**: Publish to message bus\n\n\
        Decision tree:\nIF urgent OR needs_response: USE direct_message\nELIF data_artifact:\
        \ USE state_entity  \nELIF broadcast_update: USE message_bus\n{{/if}}\n"
orchestration_logic:
  strategy: "## Phase 1: Experiment Setup\nSTATE experiments = []\nSTATE coordination_methods\
    \ = {{coordination_methods}}\n\nTRACK {\n  event: \"coordination_lab_started\"\
    ,\n  research_topic: \"{{research_topic}}\",\n  methods: coordination_methods,\n\
    \  team_size: {{team_size}}\n}\n\n## Phase 2: Run Coordination Experiments\nFOREACH\
    \ method IN coordination_methods:\n  # Create research team with specific coordination\
    \ style\n  STATE team = []\n  STATE team_performance = {\n    method: method,\n\
    \    start_time: NOW(),\n    interactions: [],\n    insights_generated: 0,\n \
    \   coordination_efficiency: 0.0\n  }\n  \n  # Spawn research team\n  FOREACH\
    \ i IN RANGE(1, {{team_size}} + 1):\n    EVENT agent:spawn {\n\
    \      component: \"components/personas/researchers/data_researcher\",\n     \
    \ vars: {\n        agent_id: \"researcher_{{method}}_{{i}}\",\n        coordination_style:\
    \ method,\n        research_topic: \"{{research_topic}}\",\n        team_members:\
    \ MAP(RANGE(1, {{team_size}} + 1), x => \"researcher_{{method}}_{{x}}\")\n   \
    \   }\n    } AS agent\n    \n    STATE team = APPEND(team, agent.agent_id)\n \
    \ \n  # Give team initial research task\n  EVENT state:entity:create {\n    type:\
    \ \"research_task\",\n    id: \"task_{{method}}\",\n    properties: {\n      topic:\
    \ \"{{research_topic}}\",\n      subtopics: GENERATE_SUBTOPICS(\"{{research_topic}}\"\
    , {{team_size}}),\n      coordination_method: method,\n      team: team\n    }\n\
    \  }\n  \n  # Start research with coordination monitoring\n  FOREACH agent_id\
    \ IN team:\n    EVENT completion:async {\n      agent_id: agent_id,\n      prompt:\
    \ \"Research {{research_topic}} focusing on your assigned subtopic. Coordinate\
    \ with your team using {{method}} style.\",\n      event_notification: {\n   \
    \     event: \"research:progress\",\n        data: {\n          agent_id: agent_id,\n\
    \          method: method\n        }\n      }\n    }\n  \n  # Monitor coordination\
    \ patterns for experiment duration\n  STATE monitoring_start = NOW()\n  STATE\
    \ coordination_events = []\n  \n  WHILE ELAPSED_TIME(monitoring_start) < {{experiment_duration}}\
    \ * 60:\n    # Collect coordination events\n    EVENT monitor:get_events {\n \
    \     event_patterns: [\"completion:async\", \"state:entity:*\", \"message:*\"\
    , \"insight:shared\"],\n      filter: {\n        \"$or\": [\n          {\"data.agent_id\"\
    : {\"$in\": team}},\n          {\"_agent_id\": {\"$in\": team}}\n        ]\n \
    \     },\n      since: monitoring_start\n    } AS events\n    \n    STATE coordination_events\
    \ = MERGE_UNIQUE(coordination_events, events.events)\n    \n    # Analyze coordination\
    \ patterns\n    STATE interaction_count = COUNT_INTERACTIONS(coordination_events,\
    \ team)\n    STATE insight_quality = ASSESS_INSIGHTS(coordination_events)\n  \
    \  STATE coordination_overhead = MEASURE_OVERHEAD(coordination_events)\n    \n\
    \    # Update metrics\n    STATE team_performance.interactions = coordination_events\n\
    \    STATE team_performance.insights_generated = COUNT_INSIGHTS(coordination_events)\n\
    \    STATE team_performance.coordination_efficiency = insight_quality / (1 + coordination_overhead)\n\
    \    \n    WAIT 30  # Check every 30 seconds\n  \n  STATE team_performance.end_time\
    \ = NOW()\n  STATE team_performance.duration = ELAPSED_TIME(team_performance.start_time)\n\
    \  \n  # Terminate research team\n  FOREACH agent_id IN team:\n    EVENT agent:terminate\
    \ {\n      agent_id: agent_id,\n      reason: \"Experiment complete\"\n    }\n\
    \  \n  STATE experiments = APPEND(experiments, team_performance)\n  \n  TRACK\
    \ {\n    event: \"coordination_experiment_complete\",\n    method: method,\n \
    \   insights_generated: team_performance.insights_generated,\n    efficiency:\
    \ team_performance.coordination_efficiency\n  }\n\n## Phase 3: Comparative Analysis\n\
    SEND {\n  to: coordination_researcher,\n  message: {\n    action: \"analyze_coordination_patterns\"\
    ,\n    experiments: experiments,\n    criteria: [\n      \"insight_generation_rate\"\
    ,\n      \"coordination_overhead\",\n      \"information_sharing_efficiency\"\
    ,\n      \"emergent_behaviors\",\n      \"scalability_potential\"\n    ]\n  }\n\
    }\n\nAWAIT {\n  from: coordination_researcher,\n  timeout: 300\n} AS analysis\n\
    \n## Phase 4: Hybrid Optimization\n# Design optimal hybrid approach based on findings\n\
    STATE optimal_hybrid = {\n  urgent_communication: analysis.best_for_urgent,\n\
    \  data_sharing: analysis.best_for_data,\n  broadcast_updates: analysis.best_for_broadcast,\n\
    \  decision_rules: analysis.optimal_decision_tree\n}\n\n# Create optimized coordination\
    \ pattern\nEVENT composition:create_component {\n  name: \"orchestrations/coordination/optimal_{{research_topic|slugify}}\"\
    ,\n  content: GENERATE_COORDINATION_PATTERN(optimal_hybrid, analysis),\n  metadata:\
    \ {\n    discovered_by: \"coordination_lab\",\n    research_topic: \"{{research_topic}}\"\
    ,\n    optimal_methods: optimal_hybrid,\n    performance_gain: analysis.hybrid_improvement\n\
    \  }\n}\n\n## Phase 5: Meta-Insights\nSTATE meta_insights = {\n  topic_coordination_fit:\
    \ analysis.topic_specific_patterns,\n  team_size_effects: analysis.scalability_analysis,\n\
    \  communication_overhead: analysis.overhead_patterns,\n  emergent_behaviors:\
    \ analysis.unexpected_patterns,\n  hybrid_advantages: analysis.hybrid_benefits\n\
    }\n\n# Store learnings\nEVENT state:entity:update {\n  id: \"coord_lab_{{research_topic|slugify}}\"\
    ,\n  properties: {\n    methods_tested: coordination_methods,\n    results: experiments,\n\
    \    optimal_patterns: optimal_hybrid,\n    meta_insights: meta_insights,\n  \
    \  recommendations: analysis.recommendations\n  }\n}\n\n## Phase 6: Report\nSTATE\
    \ lab_report = {\n  research_topic: \"{{research_topic}}\",\n  methods_tested:\
    \ coordination_methods,\n  winner: analysis.overall_best_method,\n  hybrid_design:\
    \ optimal_hybrid,\n  performance_comparison: MAP(experiments, e => {\n    method:\
    \ e.method,\n    insights: e.insights_generated,\n    efficiency: e.coordination_efficiency\n\
    \  }),\n  key_findings: analysis.key_findings,\n  next_experiments: analysis.suggested_experiments\n\
    }\n\nTRACK {\n  event: \"coordination_lab_complete\",\n  report: lab_report\n\
    }\n\nEVENT orchestration:request_termination {\n  reason: \"Coordination experiments\
    \ complete\",\n  optimal_method: analysis.overall_best_method,\n  report: lab_report\n\
    }\n"
helpers:
  GENERATE_SUBTOPICS: Break research topic into subtopics for team
  COUNT_INTERACTIONS: Count coordination events between agents
  ASSESS_INSIGHTS: Evaluate quality of generated insights
  MEASURE_OVERHEAD: Calculate coordination overhead
  COUNT_INSIGHTS: Count unique insights discovered
  MERGE_UNIQUE: Merge arrays removing duplicates
  GENERATE_COORDINATION_PATTERN: Create orchestration from optimal pattern
metadata:
  pattern_type: coordination_research
  experiment_type: comparative_analysis
  domains:
  - knowledge_work
  - research
  - collaboration
  tags:
  - coordination
  - communication
  - optimization
  - research
performance:
  expected_duration: '{{experiment_duration}} minutes per method'
  resource_usage: '{{team_size}} agents per experiment'
  insights_expected: Optimal coordination patterns for domain
