name: orchestration_factory
component_type: orchestration
version: 1.0.0
description: 'A meta-orchestration that discovers, creates, and optimizes coordination
  patterns.

  This factory spawns experimental orchestrations, evaluates their effectiveness,

  optimizes successful patterns, and crystallizes them into reusable components.

  The ultimate self-improving system for agent coordination.

  '
author: ksi_system
timestamp: 2025-07-23 20:00:00+00:00
variables:
  experiment_domain: '{{experiment_domain|default:''knowledge_work''}}'
  experiment_hours: '{{experiment_hours|default:2}}'
  optimization_threshold: '{{optimization_threshold|default:0.7}}'
  crystallization_threshold: '{{crystallization_threshold|default:0.85}}'
agents:
  factory_director:
    component: components/core/system_orchestrator
    expanded_capabilities:
    - orchestration
    vars:
      agent_id: factory_director
    prompt: 'You direct an orchestration factory that discovers optimal coordination
      patterns.


      ## MANDATORY: Start with:

      {"event": "agent:status", "data": {"agent_id": "{{agent_id}}", "status": "factory_initialized",
      "domain": "{{experiment_domain}}"}}


      ## Factory Mission:

      Discover, test, optimize, and crystallize the best coordination patterns for
      {{experiment_domain}}.


      ## Your Process:

      1. **Generate Hypotheses**: What coordination patterns might work?

      2. **Design Experiments**: Create test orchestrations

      3. **Run Tournaments**: Compare different approaches

      4. **Optimize Winners**: Use DSPy/MIPROv2 on successful patterns

      5. **Crystallize Excellence**: Save the best as new orchestrations


      ## MANDATORY: Initialize factory state:

      {"event": "state:entity:create", "data": {"type": "factory_state", "id": "orchestration_factory",
      "properties": {"experiments_run": 0, "patterns_discovered": [], "optimizations_completed":
      0, "domain": "{{experiment_domain}}"}}}


      ## Experimental Patterns to Try:

      - **Parallel Processing**: Multiple agents work on subtasks

      - **Pipeline Pattern**: Sequential processing with handoffs

      - **Swarm Intelligence**: Emergent behavior from simple rules

      - **Adversarial Synthesis**: Competing teams find truth

      - **Hierarchical Delegation**: Tree-structured task distribution

      - **Consensus Formation**: Agents reach agreement

      - **Evolution Strategy**: Survival of fittest approaches


      Your goal: Create an ever-improving library of coordination patterns.

      '
  pattern_designer:
    component: components/core/system_orchestrator
    vars:
      agent_id: pattern_designer
    prompt: 'You design experimental orchestration patterns for testing.


      ## MANDATORY: Start with:

      {"event": "agent:status", "data": {"agent_id": "{{agent_id}}", "status": "designer_ready"}}


      When asked to create a pattern:

      1. Consider the coordination hypothesis

      2. Design agent roles and interactions

      3. Create orchestration YAML structure

      4. Include measurement criteria


      Focus on patterns that could work for {{experiment_domain}}.

      '
  performance_analyst:
    component: components/personas/analysts/ksi_aware_analyst
    vars:
      agent_id: performance_analyst
      analysis_focus: orchestration_effectiveness
  optimization_specialist:
    component: components/agents/dspy_optimization_agent
    vars:
      agent_id: optimization_specialist
orchestration_logic:
  strategy: "## Phase 1: Hypothesis Generation\nSTATE coordination_hypotheses = [\n\
    \  {\n    name: \"research_swarm\",\n    hypothesis: \"Many agents exploring in\
    \ parallel with stigmergic coordination\",\n    domain_fit: ASSESS_FIT(\"{{experiment_domain}}\"\
    , \"parallel_exploration\")\n  },\n  {\n    name: \"debate_synthesis\", \n   \
    \ hypothesis: \"Adversarial teams arguing positions leads to better insights\"\
    ,\n    domain_fit: ASSESS_FIT(\"{{experiment_domain}}\", \"adversarial_synthesis\"\
    )\n  },\n  {\n    name: \"recursive_delegation\",\n    hypothesis: \"Agents spawning\
    \ sub-orchestrations for complex tasks\",\n    domain_fit: ASSESS_FIT(\"{{experiment_domain}}\"\
    , \"hierarchical_decomposition\")\n  },\n  {\n    name: \"emergent_consensus\"\
    ,\n    hypothesis: \"Agents self-organize into optimal configurations\",\n   \
    \ domain_fit: ASSESS_FIT(\"{{experiment_domain}}\", \"self_organization\")\n \
    \ }\n]\n\n# Sort by domain fit\nSTATE hypotheses = SORT(coordination_hypotheses,\
    \ \"domain_fit\", \"DESC\")\nSTATE experiments_to_run = SELECT_TOP(hypotheses,\
    \ 3)\n\nTRACK {\n  event: \"hypotheses_generated\",\n  count: LENGTH(hypotheses),\n\
    \  selected: MAP(experiments_to_run, \"name\"),\n  domain: \"{{experiment_domain}}\"\
    \n}\n\n## Phase 2: Experimental Design\nSTATE experimental_patterns = []\n\nFOREACH\
    \ hypothesis IN experiments_to_run:\n  SEND {\n    to: pattern_designer,\n   \
    \ message: {\n      action: \"design_orchestration\",\n      hypothesis: hypothesis,\n\
    \      domain: \"{{experiment_domain}}\",\n      constraints: {\n        max_agents:\
    \ 5,\n        max_duration: \"30 minutes\",\n        must_be_measurable: true\n\
    \      }\n    }\n  }\n  \n  AWAIT {\n    from: pattern_designer,\n    timeout:\
    \ 300\n  } AS pattern_design\n  \n  # Create experimental orchestration\n  EVENT\
    \ composition:create_component {\n    name: \"orchestrations/experiments/{{hypothesis.name}}_{{TIMESTAMP()}}\"\
    ,\n    content: pattern_design.orchestration_yaml,\n    metadata: {\n      experiment_id:\
    \ \"exp_{{hypothesis.name}}\",\n      hypothesis: hypothesis.hypothesis,\n   \
    \   created_by: \"orchestration_factory\"\n    }\n  } AS created_pattern\n  \n\
    \  STATE experimental_patterns = APPEND(experimental_patterns, {\n    pattern_name:\
    \ created_pattern.name,\n    hypothesis: hypothesis,\n    metrics: pattern_design.success_metrics\n\
    \  })\n\n## Phase 3: Tournament Execution\nTRACK {\n  event: \"tournament_starting\"\
    ,\n  patterns: LENGTH(experimental_patterns),\n  domain: \"{{experiment_domain}}\"\
    \n}\n\n# Run patterns in parallel with test scenarios\nSTATE test_scenarios =\
    \ GENERATE_SCENARIOS(\"{{experiment_domain}}\", 3)\nSTATE pattern_results = {}\n\
    \nFOREACH pattern IN experimental_patterns:\n  STATE pattern_scores = []\n  \n\
    \  FOREACH scenario IN test_scenarios:\n    # Spawn experimental orchestration\n\
    \    EVENT orchestration:start {\n      pattern: pattern.pattern_name,\n     \
    \ vars: {\n        scenario: scenario,\n        measurement_mode: true\n     \
    \ }\n    } AS experiment_run\n    \n    # Wait for completion (with timeout)\n\
    \    WAIT_FOR_ORCHESTRATION(experiment_run.orchestration_id, timeout=\"30 minutes\"\
    )\n    \n    # Get results\n    EVENT orchestration:get_results {\n      orchestration_id:\
    \ experiment_run.orchestration_id\n    } AS results\n    \n    STATE pattern_scores\
    \ = APPEND(pattern_scores, {\n      scenario: scenario,\n      score: CALCULATE_SCORE(results,\
    \ pattern.metrics),\n      execution_time: results.duration,\n      resource_usage:\
    \ results.agent_count\n    })\n  \n  STATE pattern_results[pattern.pattern_name]\
    \ = {\n    hypothesis: pattern.hypothesis,\n    average_score: AVERAGE(MAP(pattern_scores,\
    \ \"score\")),\n    scores: pattern_scores,\n    efficiency: CALCULATE_EFFICIENCY(pattern_scores)\n\
    \  }\n\n## Phase 4: Analysis and Optimization\nSEND {\n  to: performance_analyst,\n\
    \  message: {\n    action: \"analyze_tournament\",\n    results: pattern_results,\n\
    \    domain: \"{{experiment_domain}}\",\n    identify: [\"winners\", \"promising_patterns\"\
    , \"failure_modes\"]\n  }\n}\n\nAWAIT {\n  from: performance_analyst,\n  timeout:\
    \ 300\n} AS analysis\n\n# Select patterns for optimization\nSTATE optimization_candidates\
    \ = FILTER(\n  pattern_results,\n  score >= {{optimization_threshold}} AND score\
    \ < {{crystallization_threshold}}\n)\n\nSTATE crystallization_candidates = FILTER(\n\
    \  pattern_results,\n  score >= {{crystallization_threshold}}\n)\n\n## Phase 5:\
    \ Pattern Optimization\nFOREACH candidate IN optimization_candidates:\n  SEND\
    \ {\n    to: optimization_specialist,\n    message: {\n      action: \"optimize_orchestration\"\
    ,\n      pattern: candidate.pattern_name,\n      current_score: candidate.average_score,\n\
    \      improvement_areas: analysis.improvement_suggestions[candidate.pattern_name]\n\
    \    }\n  }\n  \n  # Trigger optimization orchestration\n  EVENT orchestration:start\
    \ {\n    pattern: \"orchestrations/simple_component_optimization\",\n    vars:\
    \ {\n      target_component: candidate.pattern_name,\n      optimization_objective:\
    \ \"Improve \" + JOIN(analysis.improvement_suggestions[candidate.pattern_name],\
    \ \", \")\n    }\n  } AS optimization_job\n  \n  TRACK {\n    event: \"optimization_started\"\
    ,\n    pattern: candidate.pattern_name,\n    optimization_id: optimization_job.orchestration_id\n\
    \  }\n\n## Phase 6: Crystallization\nFOREACH winner IN crystallization_candidates:\n\
    \  # Create production-ready version\n  EVENT composition:get_component {\n  \
    \  name: winner.pattern_name\n  } AS winning_pattern\n  \n  # Add to permanent\
    \ library with documentation\n  EVENT composition:create_component {\n    name:\
    \ \"orchestrations/{{experiment_domain}}/{{winner.hypothesis.name}}\",\n    content:\
    \ winning_pattern.content + \"\\n\\n# Discovered by Orchestration Factory\\n#\
    \ Score: \" + winner.average_score + \"\\n# Domain: {{experiment_domain}}\",\n\
    \    metadata: {\n      discovered_by: \"orchestration_factory\",\n      discovery_date:\
    \ NOW(),\n      performance_score: winner.average_score,\n      domain: \"{{experiment_domain}}\"\
    ,\n      hypothesis_validated: winner.hypothesis.hypothesis\n    }\n  }\n  \n\
    \  TRACK {\n    event: \"pattern_crystallized\",\n    pattern: winner.hypothesis.name,\n\
    \    score: winner.average_score,\n    location: \"orchestrations/{{experiment_domain}}/{{winner.hypothesis.name}}\"\
    \n  }\n\n## Phase 7: Meta-Learning\n# Update factory's understanding\nEVENT state:entity:update\
    \ {\n  id: \"orchestration_factory\",\n  properties: {\n    experiments_run: LENGTH(experimental_patterns),\n\
    \    patterns_discovered: APPEND(\n      GET_STATE(\"patterns_discovered\"),\n\
    \      MAP(crystallization_candidates, \"hypothesis.name\")\n    ),\n    optimizations_completed:\
    \ LENGTH(optimization_candidates),\n    learning: {\n      domain: \"{{experiment_domain}}\"\
    ,\n      successful_patterns: analysis.key_insights,\n      failure_modes: analysis.failure_patterns\n\
    \    }\n  }\n}\n\n# Self-improvement: Optimize the factory itself\nIF LENGTH(pattern_results)\
    \ > 10:  # After sufficient experiments\n  EVENT composition:track_decision {\n\
    \    pattern: \"orchestration_factory\",\n    decision: \"meta_optimization\"\
    ,\n    context: {\n      domain: \"{{experiment_domain}}\",\n      success_rate:\
    \ LENGTH(crystallization_candidates) / LENGTH(experimental_patterns),\n      insights:\
    \ analysis.meta_insights\n    },\n    confidence: 0.9\n  }\n\n## Phase 8: Report\
    \ and Next Cycle\nSTATE factory_report = {\n  cycle_id: \"factory_{{TIMESTAMP()}}\"\
    ,\n  domain: \"{{experiment_domain}}\",\n  experiments_run: LENGTH(experimental_patterns),\n\
    \  patterns_optimized: LENGTH(optimization_candidates),\n  patterns_crystallized:\
    \ LENGTH(crystallization_candidates),\n  top_discovery: crystallization_candidates[0]\
    \ OR null,\n  meta_insights: analysis.meta_insights,\n  next_hypotheses: GENERATE_NEXT_HYPOTHESES(analysis)\n\
    }\n\nEVENT orchestration:request_termination {\n  reason: \"Factory cycle complete\"\
    ,\n  report: factory_report,\n  continue: true  # Factory can run continuously\n\
    }\n"
helpers:
  ASSESS_FIT: Evaluate how well a hypothesis fits the domain
  GENERATE_SCENARIOS: Create test scenarios for the domain
  CALCULATE_SCORE: Score orchestration performance against metrics
  CALCULATE_EFFICIENCY: Measure resource usage vs output quality
  GENERATE_NEXT_HYPOTHESES: Use insights to propose new experiments
metadata:
  pattern_type: meta_orchestration
  discovery_method: experimental_evolution
  optimization_integrated: true
  tags:
  - meta
  - factory
  - discovery
  - self-improving
performance:
  expected_duration: 2+ hours for full cycle
  resource_usage: 4-5 persistent agents + spawned experiments
  discovery_rate: 1-3 new patterns per cycle
