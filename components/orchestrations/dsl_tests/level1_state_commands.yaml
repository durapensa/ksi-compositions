name: level1_state_commands
component_type: orchestration
version: 1.0.0
description: |
  Level 1 test: Atomic DSL state commands.
  Tests interpretation of STATE, UPDATE, and APPEND primitives.
  Uses lean DSL interpreter that relies on agent intelligence.
author: ksi_system
timestamp: 2025-01-18T00:00:00Z

agents:
  # Lean DSL interpreter - trusts agent intelligence
  dsl_executor:
    component: "components/core/base_agent"
    vars:
      agent_id: "dsl_executor"
      prompt: |
        You interpret and execute DSL commands using your understanding of KSI.
        
        ## MANDATORY: Start with:
        {"event": "agent:status", "data": {"agent_id": "{{agent_id}}", "status": "dsl_interpreter_ready"}}
        
        The DSL is designed to be self-evident. Trust your understanding of:
        - How state management works
        - What these commands naturally mean
        - How to emit appropriate KSI events
        
        Execute each command and track your state internally.

  # Comparison: verbose interpreter
  verbose_executor:
    component: "components/core/dsl_interpreter_orchestrator"
    vars:
      agent_id: "verbose_executor"
      pattern_name: "state_test"

  # Test evaluator
  evaluator:
    component: "components/core/base_agent"
    vars:
      agent_id: "evaluator"
      prompt: |
        You evaluate DSL interpretation accuracy.
        
        ## MANDATORY: Start with:
        {"event": "agent:status", "data": {"agent_id": "{{agent_id}}", "status": "evaluator_ready"}}
        
        Compare:
        1. Lean interpreter results vs expected
        2. Verbose interpreter results vs expected
        3. Which approach is more natural?
        4. Token efficiency
        
        ## MANDATORY: Report evaluation:
        {"event": "state:entity:create", "data": {"type": "dsl_evaluation", "id": "state_test_result", "properties": {"lean_success": true/false, "verbose_success": true/false, "recommendation": "...", "insights": [...]}}}

variables:
  test_name: "DSL State Commands"
  test_level: 1
  
# Test cases as orchestration logic
orchestration_logic:
  # Simple state test
  simple_state_test: |
    STATE counter = 0
    STATE name = "test"
    STATE items = []
    
    UPDATE counter = 5
    UPDATE name = "production"
    APPEND items "apple"
    APPEND items "banana"
    
    TRACK {counter: counter, name: name, items: items}
  
  # Complex state test
  complex_state_test: |
    STATE user = {id: 1, name: "Alice", score: 0}
    STATE history = []
    
    UPDATE user.score = 10
    APPEND history {action: "scored", points: 10}
    
    UPDATE user.score = user.score + 5
    APPEND history {action: "bonus", points: 5}
    
    TRACK {user: user, history_length: LENGTH(history)}

expected_results:
  simple_test:
    counter: 5
    name: "production"
    items: ["apple", "banana"]
  complex_test:
    user: {id: 1, name: "Alice", score: 15}
    history_length: 2

metadata:
  test_category: atomic_dsl_primitives
  dsl_constructs_tested:
    - STATE
    - UPDATE
    - APPEND
  comparison_focus:
    - interpretation_accuracy
    - natural_understanding
    - token_efficiency
  hypothesis: "Lean interpreter performs as well with fewer tokens"